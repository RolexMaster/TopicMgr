<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>XML GUI 협업 편집기</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/themes/default/style.min.css" />
<style>
  body { font-family: sans-serif; margin: 20px; }
  #tree-container { border: 1px solid #ccc; height: 300px; overflow: auto; margin-top: 8px; }
  .toolbar { margin: 8px 0; }
  .status { margin-left: 8px; font-size: 12px; }
  textarea { width: 100%; height: 120px; margin-top: 12px; }
</style>
</head>
<body>
<h1>XML GUI 협업 편집기</h1>

<p>
  Room: <input type="text" id="roomName" value="testroom">
  <button id="btnJoin">입장</button>
  <span class="status" id="connStatus">연결 안 됨</span>
</p>

<div class="toolbar">
  <button id="btnAdd">노드 추가</button>
  <button id="btnRename">이름 변경</button>
  <button id="btnDelete">삭제</button>
</div>

<div id="tree-container"></div>

<h3>메모(실시간 동기화 테스트: Y.Text)</h3>
<textarea id="notes" placeholder="여기에 입력하면 다른 탭/브라우저에서 바로 보입니다."></textarea>

<script type="module">
  import * as Y from 'https://esm.sh/yjs@13.6.27';
  import { WebsocketProvider } from 'https://esm.sh/y-websocket@2.0.4';
  import 'https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js';
  import 'https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/jstree.min.js';

  
  let ydoc, provider, ymap, ytext, jstreeInstance;
  let isApplyingRemoteNotes = false;
  let isComposing = false;   // 한글/IME 조합 중
  let lastYValue = '';       // 마지막 Y.Text 문자열(로컬 기준)

  const $ = window.jQuery;

  document.getElementById('btnJoin').addEventListener('click', joinRoom);

  function joinRoom() {
    const roomName = document.getElementById('roomName').value.trim();
    if (!roomName) return;

    ydoc = new Y.Doc();
    ymap = ydoc.getMap('treeData');
    ytext = ydoc.getText('notes');

    const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const url = `${protocol}//${location.host}/ws`;

    provider = new WebsocketProvider(url, roomName, ydoc, { connect: false });

   

    // 상태 로그 & 표시
    provider.on('status', e => {
      document.getElementById('connStatus').textContent = `상태: ${e.status}`;
      console.log('[status]', e.status);

      if (e.status === 'connected') {
       

      }
    });


    provider.on('connection-open', () => {
      console.log('[ws] open');
      if (provider.ws) provider.ws.binaryType = 'arraybuffer';
    });
    provider.on('connection-close', ev => {
      console.warn('[ws] close', ev?.code, ev?.reason);
    });
    provider.on('connection-error', err => {
      console.error('[ws] error', err);
    });
    provider.on('sync', (synced) => {
    if (!synced) return;
    const dataStr = ymap.get('treeData');
    if (dataStr) {
        applyTreeFromString(dataStr);
    } else {
        const def = JSON.stringify([{ id: 'root', text: 'Applications', state: { opened: true } }]);
        ymap.set('treeData', def);
        applyTreeFromString(def);
    }
    // 초기 notes 반영 전, 기준값 저장
    lastYValue = ytext.toString();
    notesApplyFromY();
    });


    // 문서 업데이트 로그(디버그용)
    ydoc.on('update', u => console.log('[ydoc update bytes]', u.byteLength));

    // 원격 변경 반영
    ymap.observe(() => updateTreeFromShared());
    ytext.observe((event) => {
    // 로컬 트랜잭션은 무시(에코 방지), 원격 변경만 textarea에 반영
    if (event.transaction && event.transaction.local) return;
    lastYValue = ytext.toString();
    notesApplyFromY();
    });


    initTree();
    initNotesBinding();

    // 마지막에 명시적으로 연결
    provider.connect();
  }

  /** ----- jsTree 초기화 & 이벤트 → 공유 반영 ----- */
  function initTree() {
    $('#tree-container').jstree({
      core: {
        data: [{ id: 'root', text: 'Applications', state: { opened: true } }],
        check_callback: true
      },
      plugins: ['dnd', 'wholerow', 'contextmenu']
    });
    jstreeInstance = $('#tree-container').jstree(true);

    $('#tree-container')
      .on('create_node.jstree rename_node.jstree delete_node.jstree move_node.jstree', () => {
        const treeData = jstreeInstance.get_json('#', { flat: false });
        ymap.set('treeData', JSON.stringify(treeData));
      });

    document.getElementById('btnAdd').onclick = () => {
      const sel = jstreeInstance.get_selected(true)[0] || jstreeInstance.get_node('root');
      const newNode = jstreeInstance.create_node(sel, { text: '새 노드' }, 'last');
      if (newNode) jstreeInstance.edit(newNode);
      
      const ytext = ydoc.getText('notes');
      ytext.insert(0, 'Client says hello ' + Math.random().toFixed(5) + '\n');
    };
    document.getElementById('btnRename').onclick = () => {
      const sel = jstreeInstance.get_selected(true)[0];
      if (sel) jstreeInstance.edit(sel);
    };
    document.getElementById('btnDelete').onclick = () => {
      const sel = jstreeInstance.get_selected(true)[0];
      if (sel && sel.id !== 'root') jstreeInstance.delete_node(sel);
    };
  }

  function updateTreeFromShared() {
    const dataStr = ymap.get('treeData');
    if (dataStr) applyTreeFromString(dataStr);
  }

  function applyTreeFromString(dataStr) {
    try {
      const data = JSON.parse(dataStr);
      jstreeInstance.settings.core.data = data;
      jstreeInstance.refresh();
    } catch (e) {
      console.error('트리 데이터 파싱 오류', e);
    }
  }

  /** ----- Y.Text <-> textarea 바인딩 (IME 안전) ----- */
  function initNotesBinding() {
  const ta = document.getElementById('notes');

  ta.addEventListener('compositionstart', () => { isComposing = true; });

  ta.addEventListener('compositionend', () => {
    isComposing = false;
    syncFromTextarea();  // 조합 완료된 값을 diff로 반영
  });

  ta.addEventListener('input', () => {
    if (isApplyingRemoteNotes || isComposing) return;
    syncFromTextarea();  // 매 입력마다 diff 반영
  });
}


  function notesApplyFromY() {
    if (isComposing) return;
    const ta = document.getElementById('notes');
    const newVal = ytext.toString();
    if (ta.value !== newVal) {
      isApplyingRemoteNotes = true;
      ta.value = newVal;
      isApplyingRemoteNotes = false;
    }
  }
  function syncFromTextarea() {
  const ta = document.getElementById('notes');
  const oldStr = lastYValue;
  const newStr = ta.value;

  if (oldStr === newStr) return;

  // 공통 prefix
  let p = 0;
  const minLen = Math.min(oldStr.length, newStr.length);
  while (p < minLen && oldStr.charCodeAt(p) === newStr.charCodeAt(p)) p++;

  // 공통 suffix
  let oldEnd = oldStr.length - 1;
  let newEnd = newStr.length - 1;
  while (oldEnd >= p && newEnd >= p &&
         oldStr.charCodeAt(oldEnd) === newStr.charCodeAt(newEnd)) {
    oldEnd--; newEnd--;
  }

  const deleteLen = (oldEnd - p + 1);
  const insertText = newStr.slice(p, newEnd + 1);

  if (deleteLen > 0) ytext.delete(p, deleteLen);
  if (insertText.length > 0) ytext.insert(p, insertText);

  lastYValue = newStr;  // 로컬 기준 최신값 갱신
}

</script>
</body>
</html>
